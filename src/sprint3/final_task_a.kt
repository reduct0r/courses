package sprint3
// https://contest.yandex.ru/contest/23815/run-report/143771869/
/*
-- ПРИНЦИП РАБОТЫ --
    Я реализовал модифицированный бинарный поиск для поиска элемента в циклически сдвинутом отсортированном массиве.
    Массив отсортирован по возрастанию, но сдвинут на неизвестное количество позиций, и содержит уникальные элементы.
    Алгоритм работает рекурсивно: на каждом шаге вычисляется середина (mid). Если элемент найден, то возвращается его индекс.
    Далее проверяется, отсортирована ли левая половина (arr[left] <= arr[mid]): если да, и k лежит в её диапазоне - поиск продолжается слева, иначе справа.
    Если левая не отсортирована, значит отсортирована правая: если k лежит в её диапазоне (arr[mid] < k <= arr[right-1]) поиск справа, иначе слева.
    Это позволяет постоянно сужать интервал поиска даже если встретился сдвинутая часть массива.
    Базовый случай: если left >= right, элемент не найден то возвращается -1.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    Из описания алгоритма следует, что поиск всегда сужает интервал к той половине, где может быть k, учитывая возможный сдвиг.

    Если левая половина отсортирована (arr[left] <= arr[mid]), то:
    Если k в [arr[left], arr[mid]] - он слева
    Иначе - справа
    Если правая отсортирована, то:
    Если k в (arr[mid], arr[right-1]] то он справа
    Иначе - слева

    Поскольку массив уникален и был отсортирован, диапазоны не пересекаются - алгоритм гарантированно находит k.
    Для несдвинутого массива работает как стандартный бинарный поиск.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Каждый шаг делит интервал пополам, как в бинарном поиске, с O(1) операциями на шаг.
    Глубина рекурсии - O(log n), где n это длина массива. Общая сложность O(log n) в худшем случае.
    Хвостовая рекурсия (tailrec) позволяет компилятору оптимизировать в цикл, избегая переполнения стека.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Алгоритм использует O(log n) дополнительной памяти на стек рекурсии (или O(1) после оптимизации tailrec).
    Массив не модифицируется т.е. основная память O(n), дополнительная память - константы.
    Нет выделения новых структур, амортизационная сложность не требуется.
*/

object Solution {
    fun brokenSearch(arr: IntArray, k: Int): Int {
        return binarySearch(arr, k, 0, arr.size)
    }

    tailrec fun binarySearch(arr: IntArray, x: Int, left: Int, right: Int): Int {
        if (right <= left) {
            return -1
        }
        val mid = (left + right) / 2
        if (arr[mid] == x) {
            return mid
        } else if (arr[left] <= arr[mid]) {
            if (arr[left] <= x && x <= arr[mid]) {
                return binarySearch(arr, x, left, mid)
            } else {
                return binarySearch(arr, x, mid + 1, right)
            }
        } else {
            if (arr[mid] < x && x <= arr[right - 1]) {
                return binarySearch(arr, x, mid + 1, right)
            } else {
                return binarySearch(arr, x, left, mid)
            }
        }
    }
}
