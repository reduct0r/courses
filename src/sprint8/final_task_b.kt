package sprint8_

// https://contest.yandex.ru/contest/26133/run-report/157621610/

/**
-- ПРИНЦИП РАБОТЫ --

Я использовал префиксное дерево (Trie) для хранения всех допустимых слов и динамическое программирование
для проверки возможности разбиения текста.

1. Построение Trie:
Для каждого слова проходим по его символам, создавая узлы. В конце слова ставим флаг isEnd = true.
Из корня для каждого допустимого слова мы идём по символам:
    если нужного ребёнка нет - создаём новый узел и переходим в него.
В конце слова ставим флаг isEnd = true.
Таким образом любой путь от корня до узла с флагом isEnd точно соответствует одному из слов словаря.

2. Динамическое программирование:
    1. Что такое состояние?
    dp[i] == true означает, что префикс text[0..i) можно представить как конкатенацию
    любого количества слов из данного словаря (слова можно использовать повторно и в любом порядке).
    
    2. Каков базовый случай?
    dp[0] = true - пустой префикс всегда можно «разбить» (не требуется ни одного слова).
    
    3. Каков переход?
    Для каждой позиции i, где dp[i] == true, мы начинаем обход Trie из корня и идём по тексту дальше (j = i, i+1, …).
    Как только текущий узел Trie имеет isEnd == true, это значит, что substring(i..j) - допустимое слово,
    поэтому мы устанавливаем dp[j + 1] = true. Это корректно, потому что: dp[i] гарантирует, что префикс [0..i) уже разбит,
    substring(i..j) - слово из словаря => префикс [0..j+1) = (префикс до i) + слово тоже можно разбить
    Переход учитывает все возможные разбиения, потому что мы рассматриваем все позиции начала нового слова
    и все возможные окончания слова из словаря.
    
    4. Порядок вычисления?
    Заполняем dp слева направо (от i = 0 до n-1). Для каждой достигнутой позиции i запускаем
    проход по тексту вперёд. Как только dp[n] становится true - можно сразу возвращать YES.
    
    5. Что является ответом?
    dp[n] - можно ли разбить весь текст полностью.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Корректность Trie:
    Каждый путь от корня до узла с isEnd = true соответствует ровно одному слову из входного словаря.
    Ни одно лишнее слово не может появиться, потому что мы добавляем только те слова, которые даны на входе.
    Поиск префикса по тексту в Trie гарантирует, что мы проверяем только слова, реально присутствующие в словаре.

По индукции:
    Докажем корректность по индукции по длине префикса i (0 ≤ i ≤ n).

База индукции:
    dp[0] = true — верно по определению.

Шаг индукции:
    Предположим, что для всех позиций < k значение dp верно.
    Рассмотрим позицию k.
    Если dp[k] = true, то существует хотя бы одно разбиение префикса длины k.
    При обработке этой позиции i = k мы перебираем все возможные продолжения,
    которые существуют в Trie. Если какое-то продолжение заканчивается словом (isEnd),
    то префикс длины j+1 тоже можно разбить: (разбиение до k) + найденное слово.
    Все такие j+1 будут помечены корректно.
    Если же dp[k] осталось false, значит ни одно допустимое слово не начинается в позиции k,
    что тоже верно по предположению индукции.

Таким образом, по индукции dp[n] корректно определяет, можно ли разбить всю строку.
Алгоритм учитывает повторное использование слов и любой порядок.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
L - макс. длина слова
|T| - длина исходного текста
n - кол-во слов

Построение Trie: O(n * L)
DP: в худшем случае O(|T| * L),
    для каждой позиции i (0..|T|) мы запускаем проход по Trie,
    но максимальная глубина любого пути в Trie равна L,
    поэтому внутренний цикл выполняется не более L раз для каждой i.
Итого O((n + |T|) * L) = O(|T| * L)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Trie: O(n * L)
    Массив dp: O(|T|)
    Итого O(n * L + |T|)
 */

class TrieNode {
    val children: MutableMap<Char, TrieNode> = mutableMapOf()
    var isEnd: Boolean = false
}

class Trie {
    val root = TrieNode()

    fun add(str: String) {
        var curr = root
        for (c in str) {
            curr = curr.children.getOrPut(c) { TrieNode() }
        }
        curr.isEnd = true
    }
}

fun canSplitByWords(text: String, trie: Trie): Boolean {
    val n = text.length
    val dp = BooleanArray(n + 1)
    dp[0] = true

    for (i in 0 until n) {
        if (!dp[i]) continue

        var curr = trie.root
        for (j in i until n) {
            val nextNode = curr.children[text[j]] ?: break

            curr = nextNode
            if (curr.isEnd) {
                dp[j + 1] = true
            }
        }
        if (dp[n]) return true
    }
    return dp[n]
}

fun main() {
    val reader = System.`in`.bufferedReader()
    val text = reader.readLine()
    val n = reader.readLine().toInt()
    val trie = Trie()

    repeat(n) {
        trie.add(reader.readLine())
    }

    println(if (canSplitByWords(text, trie)) "YES" else "NO")
}
