package sprint2

// https://contest.yandex.ru/contest/22781/run-report/142307106/
/*
-- ПРИНЦИП РАБОТЫ --
    Я реализовал оценку постфиксного выражения с использованием стека.
    Входное выражение подаётся как список строк (токенов), где каждый
    токен - либо операнд, либо оператор (+, -, *, /). Алгоритм перебирает
    токены: если токен - число, оно помещается в стек. Если токен - оператор,
    из стека извлекаются два верхних элемента (правый операнд первый),
    выполняется операция, и результат помещается обратно в стек. Для деления
    используется целочисленное округление вниз.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    Из описания алгоритма следует, что выражение оценивается в постфиксном
    порядке: операнды предшествуют операторам, что позволяет избежать скобок
    и приоритетов. Стек хранит промежуточные результаты. Для бинарных
    операторов всегда доступны два операнда сверху стека. Для деления floor
    обеспечивает правильное округление. В конце верхний элемент стека - это
    вычисленное выражение, его и возвращает функция solveExpression.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Обработка каждого токена стоит O(1): push и pop для стека и вычисления - константны.
    Для n токенов общая сложность O(n) - проход по всем элементам. Т.к. стек основан на
    Vector то амортизационная сложность O(1) из-за ресайза на токен/операцию стека или O(n) для всей функции.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Если нужен стек с n элементами, то будет создан вектор длиной n.
    Отбрасывая память на остальные переменные, то функция будет потреблять O(n) памяти
    в среднем и худшем случае. В лучшем случае O(1) - стек содержит максимум 1 элемент.
*/

import java.util.Stack
import kotlin.math.floor

fun solveExpression(str: List<String>): Int {
    val stack = Stack<Int>()

    for (el in str) {
        when (el) {
            "+" -> {
                val buf = stack.pop()
                stack.push(stack.pop() + buf)
            }
            "-" -> {
                val buf = stack.pop()
                stack.push(stack.pop() - buf)
            }
            "*" -> {
                val buf = stack.pop()
                stack.push(stack.pop() * buf)
            }
            "/" -> {
                val buf = stack.pop()
                stack.push(floor(stack.pop().toDouble() / buf.toDouble()).toInt())
            }
            else -> {
                stack.push(el.toInt())
            }
        }
    }

    return stack.pop()
}

fun main() {
    val reader = System.`in`.bufferedReader()
    print(solveExpression(reader.readLine().trim().split(" ")))
}
