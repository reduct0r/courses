package sprint7
// https://contest.yandex.ru/contest/25597/problems/#51450/2020_08_31/DfkMZElmJa

/**
-- ПРИНЦИП РАБОТЫ --
    Я реализовал алгоритм вычисления расстояния Левенштейна с помощью динамического программирования.
    Создается матрица dp размером (n+1) x (m+1), где n и m - длины строк s и t.
    dp[i][j] представляет минимальное количество операций (вставка, удаление, замена) для преобразования первых i символов s в первые j символов t.
    Базовые случаи: dp[i][0] = i (удаления), dp[0][j] = j (вставки).
    Для остальных: если символы равны, dp[i][j] = dp[i-1][j-1]; иначе dp[i][j] = 1 + min(удаление, вставка, замена).
    Результат - dp[n][m].

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    Каждая подзадача (префиксы строк) решается, а комбинация дает глобальный ответ.
    Учет трех операций (вставка, удаление, замена) покрывает все возможные преобразования.
    Совпадение символов не требует операций.
    Для пустых строк расстояние равно длине другой, что верно.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Заполнение матрицы: O(n*m), где n и m - длины строк.
    Инициализация: O(n + m).
    Общая сложность O(n*m) в худшем случае.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Матрица dp: O(n*m).
    Дополнительные переменные: O(1).
    Итого O(n*m).
 */

fun main() {
    val reader = System.`in`.bufferedReader()
    val s = reader.readLine()
    val t = reader.readLine()
    println(levenshteinDistance(s, t))
}

fun levenshteinDistance(s: String, t: String): Int {
    val n = s.length
    val m = t.length

    val dp = Array(n + 1) { IntArray(m + 1) }

    for (i in 0..n) {
        dp[i][0] = i
    }

    for (j in 0..m) {
        dp[0][j] = j
    }

    for (i in 1..n) {
        for (j in 1..m) {
            if (s[i - 1] == t[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]
            } else {
                dp[i][j] = 1 + minOf(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
            }
        }
    }

    return dp[n][m]
}