package sprint7
// https://contest.yandex.ru/contest/25597/run-report/155083384/

/**
-- ПРИНЦИП РАБОТЫ --
1. Что такое состояние?
dp[i][j] минимальное количество операций (вставка, удаление, замена), необходимых для преобразования первых i символов строки s в первые j символов строки t.

2. Каков базовый случай?
dp[i][0] = i для преобразования префикса s длины i в пустую строку нужно i удалений.
dp[0][j] = j для преобразования пустой строки в префикс t длины j нужно j вставок.

3. Каков переход?
Если s[i-1] == t[j-1], то dp[i][j] = dp[i-1][j-1] (символы совпадают, операция не нужна).
Иначе dp[i][j] = 1 + min(
dp[i-1][j]      удаление символа из s,
dp[i][j-1]      вставка символа в s,
dp[i-1][j-1]    замена символа в s на символ из t
).
Это условие возникает потому, что для выравнивания префиксов мы рассматриваем три возможные операции: удаление (игнорируем последний символ s),
вставка (добавляем символ t в конец), замена (заменяем последний символ s на t, если они разные). Минимальное значение среди них плюс 1 (стоимость операции) даёт оптимальный выбор.

4. Порядок вычисления?
Заполняем матрицу построчно от (1,1) до (n,m), так как каждое состояние зависит от предыдущих.

5. Что является ответом?
dp[n][m] - расстояние Левенштейна между полными строками s и t.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Докажем корректность с помощью математической индукции по сумме длин префиксов (i + j).

База индукции: Для i + j = 0 (пустые строки) dp[0][0] = 0, что верно.
Для i + j = 1: Либо dp[1][0] = 1 (удаление), либо dp[0][1] = 1 (вставка), что соответствует одной операции.

Шаг индукции: Предположим, что для всех префиксов с суммой длин < k dp вычислено корректно. Рассмотрим префикс с i + j = k.
Если s[i-1] == t[j-1], то оптимальное преобразование - то же, что для (i-1, j-1), без дополнительной операции (по предположению индукции корректно).
Иначе оптимальное - минимум из трёх вариантов:
Удаление: преобразовать (i-1, j) + удалить s[i-1].
Вставка: преобразовать (i, j-1) + вставить t[j-1].
Замена: преобразовать (i-1, j-1) + заменить s[i-1] на t[j-1].
Поскольку все три подзадачи имеют сумму < k, они корректны по предположению. Таким образом, мы выбираем минимум среди корректных значений +1,
что даёт корректное значение для (i,j).
По индукции алгоритм корректен для всех i,j, включая n,m.

Учёт трёх операций покрывает все возможные преобразования, так как любое редактирование можно разложить на вставки, удаления и замены.
Совпадение символов не требует операций. Для пустых строк расстояние равно длине другой, что верно.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Заполнение матрицы: O(n*m), где n и m - длины строк.
Инициализация: O(n + m).
Общая сложность O(n*m) в худшем случае.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Поскольку в переходе для dp[i][j] используются только значения из предыдущей строки (dp[i-1][*]) и текущей (dp[i][j-1]),
пространство можно оптимизировать до O(min(n,m)), храня только две строки (или одну с обновлением in-place).
Дополнительные переменные: O(1).
 */

fun main() {
    val reader = System.`in`.bufferedReader()
    val s = reader.readLine()
    val t = reader.readLine()
    println(levenshteinDistance(s, t))
}

fun levenshteinDistance(s: String, t: String): Int {
    val n = s.length
    val m = t.length
    if (n == 0) return m
    if (m == 0) return n

    // Выберем итерацию по большей строке
    var str1 = s
    var str2 = t
    var len1 = n
    var len2 = m

    if (n > m) {
        str1 = t
        str2 = s
        len1 = m
        len2 = n
    }

    var prev = IntArray(len1 + 1)
    var curr = IntArray(len1 + 1)

    for (j in 0..len1) {
        prev[j] = j
    }

    for (i in 1..len2) {
        curr[0] = i
        for (j in 1..len1) {
            if (str2[i - 1] == str1[j - 1]) {
                curr[j] = prev[j - 1]
            } else {
                val deletion = prev[j]
                val insertion = curr[j - 1]
                val substitution = prev[j - 1]
                curr[j] = 1 + minOf(deletion, insertion, substitution)
            }
        }

        val temp = prev
        prev = curr
        curr = temp
    }

    return prev[len1]
}