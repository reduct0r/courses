package sprint7
// https://contest.yandex.ru/contest/25597/run-report/155083432/

/**
-- ПРИНЦИП РАБОТЫ --
1. Что такое состояние?
dp[j] - true, если существует подмножество элементов, сумма которых равна точно j; false иначе.

2. Каков базовый случай?
dp[0] = true - пустое подмножество имеет сумму 0.
Все остальные dp[j] изначально false.

3. Каков переход?
Для каждого элемента point в массиве points:
Для j от target downto point:
dp[j] = dp[j] || dp[j - point]
Это позволяет учитывать, можно ли достичь суммы j, включив текущий point (если была достижима j - point) или без него.

4. Порядок вычисления?
Обрабатываем элементы по порядку (снаружи цикл по points).
Внутри для каждого point обновляем dp в обратном порядке (от target до point), чтобы каждый элемент использовался
не более одного раза (избегая множественного использования в рамках одного прохода).

5. Что является ответом?
Если общая сумма totalSum нечётная, возвращаем false (невозможно разбить на две равные части).
Иначе target = totalSum / 2, и ответ dp[target] (true, если достижима ровно target).

Задача сводится к задаче о полном рюкзаке, но с ограничением на один экземпляр каждого предмета, где вес и стоимость равны,
и мы проверяем достижимость ровно target.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Докажем корректность с помощью математической индукции по количеству обработанных элементов k (от 0 до n).

База индукции: Для k=0 (нет элементов), dp[0]=true, все остальные false. Это верно: только сумма 0 достижима пустым подмножеством.

Шаг индукции: Предположим, что после обработки k-1 элементов dp[j] корректно отражает достижимость j с использованием подмножества из первых k-1 элементов.
При добавлении k-го элемента (point):
Для j < point: dp[j] не меняется (остаётся от предыдущих).
Для j >= point: dp[j] становится true, если либо оно уже было true (без point), либо dp[j - point] было true (с point).
Обратный порядок гарантирует, что при обновлении dp[j] значение dp[j - point] ещё не включает множественное использование point
(поскольку мы идём справа налево, и dp[j - point] < j, так что оно уже обновлено только для предыдущих элементов или для этого с учётом меньших j).
Таким образом, каждый элемент берётся не более одного раза.
По индукции dp корректно после всех n элементов.

Если общая сумма чётная и dp[target] == true, то существует подмножество с суммой target, остаток имеет сумму target (второе подмножество).
Пустой массив (n=0) даёт сумму 0, которую можно разбить на две пустые части с суммами 0.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(n * target), где n - количество элементов, target = totalSum / 2.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Одномерный массив dp размера target + 1: O(target).
Дополнительная память: O(n).
 */

fun main() {
    val reader = System.`in`.bufferedReader()
    val n = reader.readLine().toInt()
    val line = reader.readLine()
    if (n == 0) {
        println("True")
        return
    }
    val points = line.split(" ").map { it.toInt() }.toIntArray()
    println(if (canPartition(points)) "True" else "False")
}

fun canPartition(points: IntArray): Boolean {
    if (points.isEmpty()) return true
    val totalSum = points.sum()
    if (totalSum % 2 != 0) return false
    val target = totalSum / 2
    val dp = BooleanArray(target + 1) { false }
    dp[0] = true
    for (point in points) {
        for (j in target downTo point) {
            dp[j] = dp[j] || dp[j - point]
        }
    }
    return dp[target]
}